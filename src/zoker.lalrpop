use std::str::FromStr;
use crate::ast;

grammar;

// All `pub`s are used for dev env.
pub Program: ast::Program = {
    Expression => ast::Program::Expression(<>),
};

pub Statements: Vec<ast::Statement> = {
    <mut stmts:Statements> <stmt:Statement> ";" => {
        stmts.push(stmt);
        stmts
    },
};

pub Statement: ast::Statement = {
    // TODO: If statement is ambiguous now.
    // IfStatement,
    Expression => ast::Statement {
        node: ast::StatementType::Expression(<>),
    },
};

IfStatement: ast::Statement = {
    "if" "(" <expr:Expression> ")" <if_stmt:Statement> <else_stmt:("else" Statement)?> => ast::Statement {
        node: ast::StatementType::IfStatement {
            condition: Box::new(expr),
            if_statement: Box::new(if_stmt),
            else_statement: Some(Box::new(else_stmt.unwrap().1)),
        }
    },
};

pub Expression: ast::Expression = {
    BinaryExpression,
};

pub BinaryExpression: ast::Expression = {
    LogicalOrExpression,
    AssignExpression,
};

pub AssignExpression: ast::Expression = {
    <l:Identifier> <op:AssignOperator> <r:Expression> => ast::Expression {
        node: ast::ExpressionType::AssignExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
};

AssignOperator: ast::Operator = {
    "=" => ast::Operator::Assign,
    "&=" => ast::Operator::BitAndAssign,
    "|=" => ast::Operator::BitOrAssign,
    "^=" => ast::Operator::BitXorAssign,
    "<<=" => ast::Operator::LShiftAssign,
    ">>=" => ast::Operator::RShiftAssign,
    "+=" => ast::Operator::AddAssign,
    "-=" => ast::Operator::SubAssign,
    "*=" => ast::Operator::MulAssign,
    "/=" => ast::Operator::DivAssign,
    "%=" => ast::Operator::ModAssign,
};

LogicalOrExpression: ast::Expression = {
    <l:LogicalOrExpression> "||" <r:LogicalAndExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::Or,
            right: Box::new(r),
        }
    },
    LogicalAndExpression,
};

LogicalAndExpression: ast::Expression = {
    <l:LogicalAndExpression> "&&" <r:BitOrExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::And,
            right: Box::new(r),
        }
    },
    BitOrExpression,
};

BitOrExpression: ast::Expression = {
    <l:BitOrExpression> "|" <r:BitXorExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::BitOr,
            right: Box::new(r),
        }
    },
    BitXorExpression,
};

BitXorExpression: ast::Expression = {
    <l:BitXorExpression> "^" <r:BitAndExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::BitXor,
            right: Box::new(r),
        }
    },
    BitAndExpression,
};

BitAndExpression: ast::Expression = {
    <l:BitAndExpression> "&" <r:ComparisonExpression1> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::BitAnd,
            right: Box::new(r),
        }
    },
    ComparisonExpression1,
};

pub ComparisonExpression1: ast::Expression = {
    <l:ComparisonExpression1> <op:ComparisonOperator1> <r:ComparisonExpression2> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ComparisonExpression2,
};

ComparisonOperator1: ast::Operator = {
    "==" => ast::Operator::Eq,
    "!=" => ast::Operator::NotEq,
};

pub ComparisonExpression2: ast::Expression = {
    <l:ComparisonExpression2> <op:ComparisonOperator2> <r:ArithmeticExpression1> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ArithmeticExpression1,
};

ComparisonOperator2: ast::Operator = {
    "<" => ast::Operator::Lt,
    "<=" => ast::Operator::Le,
    ">" => ast::Operator::Gt,
    ">=" => ast::Operator::Ge,
};

/// Separate Arithmetic Expression grammar for priority
///
/// Priority
/// 1.
/// ** (power operator)
/// 2.
/// * (multiplication), / (division), % (modulus)
/// 3.
/// + (addition), - (subtraction)
pub ArithmeticExpression1: ast::Expression = {
    <l:ArithmeticExpression1> <op:ArithmeticOperator1> <r:ArithmeticExpression2> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ArithmeticExpression2,
};

ArithmeticOperator1: ast::Operator = {
    "+" => ast::Operator::Add,
    "-" => ast::Operator::Sub,
};

pub ArithmeticExpression2: ast::Expression = {
    <l:ArithmeticExpression2> <op:ArithmeticOperator2> <r:PowerExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    PowerExpression,
};

ArithmeticOperator2: ast::Operator = {
    "*" => ast::Operator::Mul,
    "/" => ast::Operator::Div,
    "%" => ast::Operator::Mod,
};

pub PowerExpression: ast::Expression = {
    // TODO : The power operation should be done with 'l' as base and 'r' as exponent.
    <l:Value> <op:PowerOperator> <r:Value> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    UnaryExpression,
};

PowerOperator: ast::Operator = {
    "**" => ast::Operator::Pow,
};

pub UnaryExpression: ast::Expression = {
    // TODO: ++, -- operation must increment value.
    <v:Terminal> <op:PostfixUnaryOperator> => ast::Expression {
        node: ast::ExpressionType::UnaryExpression {
            operator: op,
            expression: Box::new(v),
        }
    },
    <op:PrefixUnaryOperator> <v:Terminal> => ast::Expression {
        node: ast::ExpressionType::UnaryExpression {
            operator: op,
            expression: Box::new(v),
        }
    },
    Value,
};

PrefixUnaryOperator: ast::Operator = {
    "++" => ast::Operator::PrefixPlusPlus,
    "--" => ast::Operator::PrefixMinusMinus,
    "+" => ast::Operator::Plus,
    "-" => ast::Operator::Minus,
    "!" => ast::Operator::Not,
};

PostfixUnaryOperator: ast::Operator = {
    "++" => ast::Operator::PostfixPlusPlus,
    "--" => ast::Operator::PostfixMinusMinus,
};

pub Value: ast::Expression = {
    Terminal,
    "(" <Expression> ")",
};

pub Terminal: ast::Expression = {
    Number,
    Identifier,
};

// TODO: Customize the lexer and change it to read the Number value from the lexer.
Number: ast::Expression = {
    r"[0-9]+" => ast::Expression {
        node: ast::ExpressionType::Number { value: i32::from_str(<>).unwrap() }
    },
};

Identifier: ast::Expression = {
    r"[a-zA-Z][_a-zA-Z0-9]*" => ast::Expression {
        node: ast::ExpressionType::Identifier { value: String::from(<>) }
    },
};
