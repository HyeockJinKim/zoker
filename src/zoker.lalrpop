use std::str::FromStr;
use crate::ast;

grammar;

// All `pub`s are used for dev env.
pub Program: ast::Program = {
    ArithmeticExpression1 => ast::Program::Expression(<>),
};

/// Separate Arithmetic Expression grammar for priority
///
/// Priority
/// 1.
/// ** (power operator)
/// 2.
/// * (multiplication), / (division), % (modulus)
/// 3.
/// + (addition), - (subtraction)
pub ArithmeticExpression1: ast::Expression = {
    <l:ArithmeticExpression1> <op:ArithmeticOperator1> <r:ArithmeticExpression2> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ArithmeticExpression2,
};

ArithmeticOperator1: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Add,
    "-" => ast::BinaryOperator::Sub,
};

pub ArithmeticExpression2: ast::Expression = {
    <l:ArithmeticExpression2> <op:ArithmeticOperator2> <r:PowerExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    PowerExpression,
};

ArithmeticOperator2: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Mul,
    "/" => ast::BinaryOperator::Div,
    "%" => ast::BinaryOperator::Mod,
};

pub PowerExpression: ast::Expression = {
    // TODO : The power operation should be done with 'l' as base and 'r' as exponent.
    <l:Value> <op:PowerOperator> <r:Value> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    UnaryExpression,
};

PowerOperator: ast::BinaryOperator = {
    "**" => ast::BinaryOperator::Pow,
};

pub UnaryExpression: ast::Expression = {
    // TODO: ++, -- operation must increment value.
    <v:Terminal> <op:PostfixUnaryOperator> => ast::Expression {
        node: ast::ExpressionType::UnaryExpression {
            operator: op,
            expression: Box::new(v),
        }
    },
    <op:PrefixUnaryOperator> <v:Terminal> => ast::Expression {
        node: ast::ExpressionType::UnaryExpression {
            operator: op,
            expression: Box::new(v),
        }
    },
    Value,
};

PrefixUnaryOperator: ast::UnaryOperator = {
    "++" => ast::UnaryOperator::PrefixPlusPlus,
    "--" => ast::UnaryOperator::PrefixMinusMinus,
    "+" => ast::UnaryOperator::Plus,
    "-" => ast::UnaryOperator::Minus,
};

PostfixUnaryOperator: ast::UnaryOperator = {
    "++" => ast::UnaryOperator::PostfixPlusPlus,
    "--" => ast::UnaryOperator::PostfixMinusMinus,
};

pub Value: ast::Expression = {
    Terminal,
    "(" <ArithmeticExpression1> ")",
};

pub Terminal: ast::Expression = {
    Number,
    // Identifier,
};

// TODO: Customize the lexer and change it to read the Number value from the lexer.
Number: ast::Expression = {
    r"[0-9]+" => ast::Expression {
        node: ast::ExpressionType::Number { value: i32::from_str(<>).unwrap() }
    },
};
