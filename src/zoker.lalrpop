use std::str::FromStr;
use crate::ast;

grammar;

// All `pub`s are used for dev env.
pub Program: ast::Program = {
    <GlobalStatements> => ast::Program::GlobalStatements(<>),
};

GlobalStatements: Vec<ast::Statement> = {
    <mut stmts:GlobalStatements> <stmt:GlobalStatement> => {
        stmts.push(stmt);
        stmts
    },
    <GlobalStatement> => vec![<>]
};

pub GlobalStatement: ast::Statement = {
    // TODO: Another global statement should be added.
    <Expression> ";" => ast::Statement {
        node: ast::StatementType::Expression(<>),
    },
};

Statements: Vec<ast::Statement> = {
    <mut stmts:Statements> <stmt:Statement> ";" => {
        stmts.push(stmt);
        stmts
    },
    <Statement> ";" => vec![<>]
};

pub Statement: ast::Statement = {
    CompoundStatement,
    <Expression> => ast::Statement {
        node: ast::StatementType::Expression(<>),
    },
};

CompoundStatement: ast::Statement = {
    "{" <stmt:Statements?> <return_value:Expression?>"}" => ast::Statement {
        node: ast::StatementType::CompoundStatement {
            statements: stmt.map_or(vec![], |x| x),
            return_value: return_value.map_or(None, |x| Some(Box::new(x))),
        }
    },
};

IfExpression: ast::Expression = {
    "if" <expr:Expression> <if_stmt:CompoundStatement> <else_stmt:("else" CompoundStatement)?> => ast::Expression {
        node: ast::ExpressionType::IfExpression {
            condition: Box::new(expr),
            if_statement: Box::new(if_stmt),
            else_statement: else_stmt.map_or(None, |x| Some(Box::new(x.1)))
        }
    },
};

pub Expression: ast::Expression = {
    BinaryExpression,
};

BinaryExpression: ast::Expression = {
    LogicalOrExpression,
    AssignExpression,
};

AssignExpression: ast::Expression = {
    <l:Identifier> <op:AssignOperator> <r:Expression> => ast::Expression {
        node: ast::ExpressionType::AssignExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
};

AssignOperator: ast::Operator = {
    "=" => ast::Operator::Assign,
    "&=" => ast::Operator::BitAndAssign,
    "|=" => ast::Operator::BitOrAssign,
    "^=" => ast::Operator::BitXorAssign,
    "<<=" => ast::Operator::LShiftAssign,
    ">>=" => ast::Operator::RShiftAssign,
    "+=" => ast::Operator::AddAssign,
    "-=" => ast::Operator::SubAssign,
    "*=" => ast::Operator::MulAssign,
    "/=" => ast::Operator::DivAssign,
    "%=" => ast::Operator::ModAssign,
};

LogicalOrExpression: ast::Expression = {
    <l:LogicalOrExpression> "||" <r:LogicalAndExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::Or,
            right: Box::new(r),
        }
    },
    LogicalAndExpression,
};

LogicalAndExpression: ast::Expression = {
    <l:LogicalAndExpression> "&&" <r:BitOrExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::And,
            right: Box::new(r),
        }
    },
    BitOrExpression,
};

BitOrExpression: ast::Expression = {
    <l:BitOrExpression> "|" <r:BitXorExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::BitOr,
            right: Box::new(r),
        }
    },
    BitXorExpression,
};

BitXorExpression: ast::Expression = {
    <l:BitXorExpression> "^" <r:BitAndExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::BitXor,
            right: Box::new(r),
        }
    },
    BitAndExpression,
};

BitAndExpression: ast::Expression = {
    <l:BitAndExpression> "&" <r:ComparisonExpression1> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: ast::Operator::BitAnd,
            right: Box::new(r),
        }
    },
    ComparisonExpression1,
};

ComparisonExpression1: ast::Expression = {
    <l:ComparisonExpression1> <op:ComparisonOperator1> <r:ComparisonExpression2> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ComparisonExpression2,
};

ComparisonOperator1: ast::Operator = {
    "==" => ast::Operator::Eq,
    "!=" => ast::Operator::NotEq,
};

ComparisonExpression2: ast::Expression = {
    <l:ComparisonExpression2> <op:ComparisonOperator2> <r:ArithmeticExpression1> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ArithmeticExpression1,
};

ComparisonOperator2: ast::Operator = {
    "<" => ast::Operator::Lt,
    "<=" => ast::Operator::Le,
    ">" => ast::Operator::Gt,
    ">=" => ast::Operator::Ge,
};

/// Separate Arithmetic Expression grammar for priority
///
/// Priority
/// 1.
/// ** (power operator)
/// 2.
/// * (multiplication), / (division), % (modulus)
/// 3.
/// + (addition), - (subtraction)
ArithmeticExpression1: ast::Expression = {
    <l:ArithmeticExpression1> <op:ArithmeticOperator1> <r:ArithmeticExpression2> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    ArithmeticExpression2,
};

ArithmeticOperator1: ast::Operator = {
    "+" => ast::Operator::Add,
    "-" => ast::Operator::Sub,
};

ArithmeticExpression2: ast::Expression = {
    <l:ArithmeticExpression2> <op:ArithmeticOperator2> <r:PowerExpression> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    PowerExpression,
};

ArithmeticOperator2: ast::Operator = {
    "*" => ast::Operator::Mul,
    "/" => ast::Operator::Div,
    "%" => ast::Operator::Mod,
};

PowerExpression: ast::Expression = {
    <l:Value> <op:PowerOperator> <r:Value> => ast::Expression {
        node: ast::ExpressionType::BinaryExpression {
            left: Box::new(l),
            operator: op,
            right: Box::new(r),
        }
    },
    UnaryExpression,
};

PowerOperator: ast::Operator = {
    "**" => ast::Operator::Pow,
};

UnaryExpression: ast::Expression = {
    <v:Terminal> <op:PostfixUnaryOperator> => ast::Expression {
        node: ast::ExpressionType::UnaryExpression {
            operator: op,
            expression: Box::new(v),
        }
    },
    <op:PrefixUnaryOperator> <v:Terminal> => ast::Expression {
        node: ast::ExpressionType::UnaryExpression {
            operator: op,
            expression: Box::new(v),
        }
    },
    Value,
};

PrefixUnaryOperator: ast::Operator = {
    "++" => ast::Operator::PrefixPlusPlus,
    "--" => ast::Operator::PrefixMinusMinus,
    "+" => ast::Operator::Plus,
    "-" => ast::Operator::Minus,
    "!" => ast::Operator::Not,
};

PostfixUnaryOperator: ast::Operator = {
    "++" => ast::Operator::PostfixPlusPlus,
    "--" => ast::Operator::PostfixMinusMinus,
};

Value: ast::Expression = {
    IfExpression,
    Terminal,
    "(" <Expression> ")",
};

Terminal: ast::Expression = {
    Number,
    Identifier,
};

Number: ast::Expression = {
    r"[0-9]+" => ast::Expression {
        node: ast::ExpressionType::Number { value: i32::from_str(<>).unwrap() }
    },
};

Identifier: ast::Expression = {
    r"[a-zA-Z][_a-zA-Z0-9]*" => ast::Expression {
        node: ast::ExpressionType::Identifier { value: String::from(<>) }
    },
};
